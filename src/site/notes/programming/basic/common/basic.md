---
{"dg-publish":true,"permalink":"/programming/basic/common/basic/"}
---


4/22

# 编码

计算机一个 0 或者一个 1，称之为 1 位（bit）

8 位等于 1 字节（byte）

1 字节数据传输的最小单位

1024byte = 1kb

## ASCII 码

上个世纪 60 年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。

ASCII 码一共规定了 128 个字符的编码，比如空格 `SPACE` 是 32（二进制 `00100000`），大写的字母 `A` 是 65（二进制 `01000001`）。这 128 个符号（包括 32 个不能打印出来的控制符号），只占用了一个字节的后面 7 位，最前面的一位统一规定为 `0`。

可以说：**ASCII 是 7 位二进制编码** ，因为它只能表示 128 个字符

## 非 ASCII 编码

英语用 128 个符号编码就够了，但是用来表示其他语言，128 个符号是不够的。

但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用 256 个符号的编码方式，代表的字母却不一样。比如，130 在法语编码中代表了 `é`，在希伯来语编码中却代表了字母 `Gimel` (`ג`)，在俄语编码中又会代表另一个符号。

但是不管怎样，所有这些编码方式中，**0--127 表示的符号是一样的，不一样的只是 128--255 的这一段。**

至于亚洲国家的文字，使用的符号就更多了，汉字就多达 10 万左右。一个字节只能表示 256 种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。

中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是 GB 类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。

## Unicode

可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。

Unicode 当然是一个很大的集合，现在的规模可以容纳 100 多万个符号。每个符号的编码都不一样，比如，`U+0639` 表示阿拉伯字母 `Ain`，`U+0041` 表示英语的大写字母 `A`，`U+4E25` 表示汉字 `严`。具体的符号对应表，可以查询 [unicode.org](http://www.unicode.org/)，或者专门的 [汉字对应表](http://www.chi2ko.com/tool/CJK.htm)。

## Unicode 的问题

需要注意的是，Unicode 只是一个**符号集**，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。

比如，汉字 `严` 的 Unicode 是十六进制数 `4E25`，转换成二进制数足足有 15 位（`100111000100101`），也就是说，这个符号的表示至少需要 2 个字节。表示其他更大的符号，可能需要 3 个字节或者 4 个字节，甚至更多。

这里就有两个严重的问题，**第一个问题是**，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？**第二个问题是**，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 `0`，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。

它们造成的结果是：

- 出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。
- Unicode 在很长一段时间内无法推广，直到互联网的出现。

## UTF-8

互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的**一种 Unicode 的实现方式**。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。**重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。**

UTF-8 最大的一个特点，**就是它是一种变长的编码方式**。它可以使用 1~4 个字节表示一个符号，根据不同的符号而变化字节长度。

UTF-8 的编码规则很简单，只有二条：

- 对于单字节的符号，字节的第一位设为 `0`，后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。
- 对于 `n` 字节的符号（`n > 1`），第一个字节的前 `n` 位都设为 `1`，第 `n + 1` 位设为 `0`，后面字节的前两位一律设为 `10`。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

下表总结了编码规则，字母 `x` 表示可用编码的位。

```js
Unicode符号范围     |        UTF-8编码方式
(十六进制)        	|       （二进制）
----------------------+---------------------------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```

跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是 `0`，则这个字节单独就是一个字符；如果第一位是 `1`，则连续有多少个 `1`，就表示当前字符占用多少个字节

**示例**

- 下面，还是以汉字 `严` 为例，演示如何实现 UTF-8 编码。
- `严` 的 Unicode 是 `4E25`（`100111000100101`）
- 根据上表，可以发现 `4E25` 处在第三行的范围内（`0000 0800 - 0000 FFFF`）
- 因此 `严` 的 UTF-8 编码需要三个字节，即格式是 `1110xxxx 10xxxxxx 10xxxxxx`。
- 然后，从 `严` 的最后一个二进制位开始，依次从后向前填入格式中的 `x`，多出的位补 `0`。
- 这样就得到了，`严` 的 UTF-8 编码是 `11100100 10111000 10100101`，转换成十六进制就是 `E4B8A5`。

## 参考

http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html

## 总结

多少个字节表示一个汉字：

  - GB2312：2 个字节
  - UTF-8 编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。中文标点占三个字节，英文标点占一个字节
  - Unicode 编码：一个英文等于两个字节，一个中文（含繁体）等于两个字节。中文标点占两个字节，英文标点占两个字节

乱码：计算机非常笨，只认识 0 和 1。编码：把字符转换成二进制；解码；编码和解码所采用的规则，成为字符集；乱码产生的根本原因：解码、编码采用的字符集不一样

在不同系统的情况系 windows 下是\,linux 和 unix 下是/ 但在 win 中没有本质区别。但是由于 \ 也是转义字符的起始字符， 所以， 路径中的 \ 通常需要使用 \\如果是 / 就不需要使用转义了. 如 C 中文件操作，c:\\kkk\\dd.txt c:/kkk/dd.txt 一样

可以注意到计算机里是\，浏览器是/，其实都可以，/就不用转义了

端口号最大 65535

路径有错误，从 word 复制到 txt 可能加上了一些空格之类的，严格对照

localhost / 127.0.0.1 代表的都是本机地址

JAVA_HOME 目录后面不可以跟分号，因为会导致目录的路径出错

字面量，所代表的值如字面所示，区别于变量，代表的值是可以变化的

SVG 矢量图格式

正斜杠 右手画斜杠，斜率为正的是正斜杠

chrome 插件的原理，在渲染好的页面中引入一个插件的 JS，然后通过 JS 就可以实现各种功能

32 位处理器是指处理器的（）是 32 位的 32 位处理器，计算机中的位数指的是 [CPU](https://baike.baidu.com/item/CPU) 一次能处理的最大位数。32 位计算机的 CPU 一次最多能处理 32 位数据

# 编程基础

一般 XX 容器，都是一个**堆结构**，**栈结构**，队列

## 命令行窗口

小黑屏、CMD 窗口、终端、shell

开始菜单 --> 运行 --> CMD --> 回车

常用的指令：

- dir 列出当前目录下的所有文件
- cd 目录名 进入到指定的目录
- md 目录名 创建一个文件夹
- rd 目录名 删除一个文件夹
- d: 进入 d 盘
- 方向键上下找历史记录

目录

- . 表示当前目录
  - ./js/js.js
  - 平时是省略./
  - 像这些最基本的编程习惯，一直被各种语言沿用、保留
- .. 表示上一级目录
  - ../css/css.css

## 环境变量（windows 系统中变量）

- windows 里的环境变量就和编程里的环境变量一样，为了让这个作用域内的都可以访问，所以设置为环境变量，方便使用
- path
  - 当我们在命令行窗口打开一个文件，或调用一个程序时，系统会首先在当前目录下寻找文件程序，如果找到了则直接打开如果没有找到则会依次到环境变量 path 的路径中寻找，直到找到为止，如果没找到则报错
- 改变环境变量之后，要重启命令行窗口

## 内存溢出

一种程序运行出现的错误

当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误

## 内存泄露

占用的内存没有及时释放

内存泄露积累多了就容易导致内存溢出

常见的内存泄露:

+ 意外的全局变量（没有使用 var 声明变量）
+ 没有及时清理的计时器或回调函数
+ 闭包

## 死锁

### 定义

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

死锁的规范定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。

### 产生条件

虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个 [必要条件](https://baike.baidu.com/item/必要条件)。 [2]

1. **互斥条件：**指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
2. **请求和保持条件：**指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
3. **不剥夺条件：**指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
4. **环路等待条件：**指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。

# 端口号

+ ftp 21
+ 远程 ssh 22
+ http 80
+ https 443

# Ping

ping 只能 ping ip 地址，没有办法指定端口号

telnet 可以加上 端口号

brew install telnet

telnet 10.138.43.88 8090

注意没有冒号

# 术语

## 驼峰命名与烧烤串命名

amelCased (驼峰式)

kebab-case（短横线命名），都是小写的，区分与驼峰式

下划线，是可以全选的，区分与短横线

## GUI 与 CUI

图形界面、命令行界面

## 洋葱圈模型

## 猴子补丁

这个叫法起源于 Zope 框架，大家在修正 Zope 的 Bug 的时候经常在程序后面追加更新部分，这些被称作是“杂牌军补丁 (guerilla patch)”，后来 guerilla 就渐渐的写成了 gorllia((猩猩)，再后来就写了 monkey(猴子)，所以猴子补丁的叫法是这么莫名其妙的得来的。

猴子补丁主要有以下几个用处：

1. 在运行时替换方法、属性等
2. 在不修改第三方代码的情况下增加原来不支持的功能
3. 在运行时为内存中的对象增加 patch 而不是在磁盘的源代码中增加

## 服务器与客户端

服务器和客户端其实都是电脑

**概念层面上：**

- 服务器：能够提供某种服务的电脑
- 客户端：使用服务器所提供的服务的电脑

**硬件层面上：**

- 服务器：由于要给千万个客户端提供服务，一般来说，服务器的硬件配置更高
- 客户端：个人电脑闹、手机、平板等都可以视为客户端
- 注意：即使是配置很差的个人电脑，也可以当做服务器来使用，只不过是服务器的速度会慢一点

服务器上的软件

- 服务器的操作系统，一般会选择 linux，而个人电脑一般会选择 windows
- 其他软件：
  - HTTP 网页服务，Apache、Tomcat、IIS 等
  - 文件上传下载服务：VsFtp 等
  - 邮箱服务：SendMail 等
  - 数据存储服务：Mysql、Oracle 等
