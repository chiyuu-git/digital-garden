---
{"aliases":["适配器模式"],"tags":[],"review-dates":[],"dg-publish":true,"date-created":"2023-10-15-Sun, 12:24:09 pm","date-modified":"2023-10-17-Tue, 6:38:07 pm","permalink":"/programming/basic/cs-basic/design-pattern/adapter-pattern/","dgPassFrontmatter":true}
---


在本章，我们将要进行一项任务，其不可能的程度，简直就像是将**一个方块放进一个圆洞中**。听起来不可能？有了设计模式，就有可能。

还记得装饰者模式吗？我们将对象包装起来，赋干它们新的职责。而现在则是以不同目的，包装某些对象: 让它们的接口看起来不像自己而像是别的东西。为何要这样做？因为这样就可以在设计中，将类的接口转换成想要的接口，以便实现不同的接 口。

不仅如此，我们还要探对另一个模式，将对象包装起来以简化其接口。

你知道适配器的作用：它位于美式插头和欧式插座的中间，它的工作是将欧式插座转换成美式插座，好让美式插头可以插进这个插座得到电力。或者也可以这么认为：适配器改变了插座的接口，以符合美式笔记本电脑的需求。

某些交流电适配器相当简单.，它们只是改变瓶座的形状来匹配你的插头，直接把电流传送过去。但是有些适配器内部则是相当复杂，可能会改变电流符合装置的需求。

好了，这是真实世界的适配器，那面向对象适配器又是什么？其实，OO 适配器和 真实世界的适配器扮演着同样的角色：将一个接转换成另一个接口，以符合客户的期望

# 引入

![](/img/user/programming/basic/cs-basic/design-pattern/adapter-pattern/image-20231015123747403.png)

# 定义

适配器模式将一个类的接口，转换成客户期望的另一 个接口。适配器让原本接口不兼容的类可以合作无间

现在，我们知道，这个模式可以通过创建适配器进行接口转换，让不兼容的接 口变成兼容。这可以让客户从实现的接口解耦。如果在一段时间之后，我们想 要改变接口，适配器可以将改变的部分封装起来，客户就不必为了应对不同的 接口而每次跟着修改。

![](/img/user/programming/basic/cs-basic/design-pattern/adapter-pattern/image-20231017181101775.png)

# FAQ

## 一个适配器需要做多 少“适配”的工作？如果我需要实现 一个很大的目标接口，似乎有“很 多”工作要做

的确是如此。实现一个适配器所需要进行的工作，的确和目标接口的大小成正比。如果不用适配器，你就必须改写客户端的代妈来调 用这个新的接口，将会花许多力气来做大量的调查工作和代马改写工作。 相比之下，提供一个适配器类，将所有方的改变封装在一个类中，是比校好的做法

## 一个适配器只能够封装一个类吗

适配器模式的工作是将 一个接口转换成另一个。虽然大多数的适配器模式所采取的例子都是让一个适配器包装一个被适配者，但我们都知道这个世界其实复杂多了，所以你可能遇到一些状况，需要让一个适配器包装多个被适业者。

这涉及另一个模式，被称为外观模式 (Facade Pattern),人们常常将外观 模式和逑配器模式混为一谈，本章稍 后将对此详细说明

## 万一我的系统中新旧并 存，旧的部分期望旧的厂商接口，但 我们却已经使用新厂商的接口编写了 这一部分，这个时候该怎么办？这里 使用适配器，那里却使用未包装的接 口，这实在是让人感到混乱。如果我 只是固守着旧的代码，完全不要管适 配器，这样子会不会好一些？

不需要如此 c 可以创建 一个双向的适配器，支椅两边的接 口 0 想创建一个双向的适配器，就必 须实现所涉及的两个接口,这样，这 个适配器可以当做旧的接口，或者当 做新的接口使用

## 对象适配器和类适配器使用两种不同的适配方法（分别是组合与继 承）。这两种实现的差异如何影响适配器的弹性

![](/img/user/programming/basic/cs-basic/design-pattern/adapter-pattern/image-20231017181243808.png)

## 某些交流电适配器所做的事情不只是改变接口，它们还加了一些其他的特性，例如：电涌保 护、指示灯、警报声等。 如果要你实现这类特性，你要使用什么模式

## 装饰者模式和适配器模式的差异

装饰者模式用于扩展类的行为, 不会改变接口

适配器模式则是改变类的接口

外观模式: 让接口更加简单
