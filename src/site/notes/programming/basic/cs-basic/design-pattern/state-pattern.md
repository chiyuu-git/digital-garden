---
{"dg-publish":true,"permalink":"/programming/basic/cs-basic/design-pattern/state-pattern/"}
---


基本常识：策略模式和状态模式是双胞胎，在出生时才分 开。你已经知道了，策略模式是困绕可以互换的算法来创建成功业务的。然 而，状态走的是更崇高的路，它通过改变对象内部的状态来帮助对象控制自己 的行为。它常常告诉它的对象客户“跟着我念：我很棒，我很聪明，我最优秀

# 引入

![](/img/user/programming/basic/cs-basic/design-pattern/state-pattern/image-20231018195234902.png)

1. 首先，找出所有的状态
2. 接下来，创建一个实例变量来持有目前的状态，然后定义每个状态的值
3. 将所有系统中可以发生的动作整合起来

## 增加新的状态造成的混乱

![](/img/user/programming/basic/cs-basic/design-pattern/state-pattern/image-20231018195922514.png)

我们要做 的事情是：首先，我们定义一个 State 接口。在这个接口内，糖果机的每个动作 都有一个对应的方法

然后为机器中的每个状态实现状态类。这些类将负责在对应的状态下进行机器的行为

最后，我们要摆脱旧的条件代码，取而代之的方式是，将动作委托到状态类

现在我们要把一个状态的所有行为放在一个类中, 这么一来我们将行为局部化了, 并使得事情更容易改变和理解

## 定义状态接口和类

![](/img/user/programming/basic/cs-basic/design-pattern/state-pattern/image-20231018200343309.png)

## 完整的糖果机类

![](/img/user/programming/basic/cs-basic/design-pattern/state-pattern/image-20231018200807271.png)

每一个状态“对修改关闭”,止糖果机“而扩展开放”，因为可以加入新的状态类

创建一个新的代码基和类结构，这更能映射万能糖果公司的图，而且更容易阅读和理解

# 定义

状态模式允许对象在内部状态改变时改变它的行为，对 象看起来好像修改了它的类。

这个描述中的第一部分附有相当多的涵义，是吧？因为这个模式将状态封装成为独立的类，并将动作 委托到代表当前状态的对象，我们知道行为会随着内部状态而改变。糖果机提供了一个很好的例子： 当糖果机是在 NoQuarterState 或 HasQuarterState 两种不同的状态时，你投入 25 分钱，就会得到不同的行 为（机器接受 25 分钱和机器拒绝 25 分钱）。

而这个定义中的第二部分呢？ 一个对象“看起来好像修改了它的类”是什么意思呢？从客户的视角来 看：如果说你使用的对象能够完全改变它的行为，那么你会觉得，这个对象实际上是从别的类实例化 而来的。然而，实际上，你知道我们是在使用组合通过简单引用不同的状态对象来造成类改变的假象。

![](/img/user/programming/basic/cs-basic/design-pattern/state-pattern/image-20231018201159634.png)

# FAQ

## 策略模式的类图和状态机模式的类图长得一模一样

但是这两个模式的差别在于它们意图

以状态模式而言, 我们将一群行为封装在状态对象中, context 的行为随时可以委托到那些状态对象中的一个. 随着时间的流逝，当前状态在状态对象集合中游走改变，以反映出 context 内部的状态，因此， context 的行为也会跟着改变。但是 context 的客户对于状态对象了解不 多，甚至根本是浑然不觉。

而以策略模式而言，客户通常主动指定 Context 所要组合的策略对象是哪一个。现在，固然策略模式让我们具有弹性，能够在运行时改变策略，但对于某个 context 对象来说，通常都只有一个最适当的策略对象。比方说，在第 1 章，有些鸭子（例如绿头鸭）被设置成利用典型的长翔行为进行飞翔，而有些鸭子（例如像皮鸭和诱饵鸭）使用的飞翔行为只能让它们紧贴地面.

一般来说，我们把策略模式想成是除了继承之外的一种弹性替代方案。如果你使用继承定义了一个类的行为，你将被这个行为困住，甚至要修改它都很难。有了策略模式，你可以通过组合不同的对象来改变行为。

我们把状态模式想成是不用在 context 中放置许多条件判断的替代方案。通过将行为包装进状态对象中.你可以通过在 context 内简单地改 变状态对象来改变 context 的行为。

![](/img/user/programming/basic/cs-basic/design-pattern/state-pattern/image-20231018202810620.png)

## 在 GumballMachine 中，状态决定了下一个 状态应该是什么。ConcreteState 总是决定接下来的状态 是什么吗

不，并非总是如此，Coniext 也可以决定状态转换的流向。

一般来讲，当状态转换是固定的时候.就适合放在 Context 中；然而，当转换是更动态的时候,通常就会放在状态类中（例如,在 GumballMachine 中.由运行时糖果的数目来决定状态矣转换到 NoQuarter 还是 SoldOut）。 将状态转换放在状态类中的缺点是：状态类之间产生了 依赖。在我们的 GumballMachine 实现中，我们试图通过 使用 Context 上的 gelter 方法把依赖减到最小，而不是显式硬编码具体状态类。

请注意，在做这个决策的同时，也等于是在为另一件事情做决簸：当系统进化时,究竟哪个类是对修改封闭（ Context 还是状态类）的

```ad-question
放在 context 中时什么场景呢, 还是不太理解

比如说, 在执行了某个 action 之后, 一定会转换到某个状态, 这个状态的转换就可以放在 context 类中
```

## 客户会直接和状态交互吗?

不会。状态是用在 Context 中来代表它的内部状态以及行为的，所以只有 Context 才会对状态提出请求。客户不会直接改变 Context 的状态。全盘了解状态是 Context 的工作，客户根本不了解，所以不会直接和状态联系。

## 如果在我的程序中 Contexl 有许多实例，这些实例之间可以共享状态对象吗

是的，绝对可以，事实上这是很常见的做法。但唯一的前提是，你的状态对象不能持有它们自己的内部状态；否则就不能共享。

想要共享状态，你需要把每个状态都指定到静态的实例变更中。如果你的状态需要利用到 Context 中的方法或者实例变量，你还必须在每个 handler。方法内传入一个 context 的引用

## 使用状态模式似乎总是增加我们设计中类的 数目。请看**GumballMachine**的例子，新版本比旧版本多 出了许多类

没微，在个别的状态类中时装状态行为，结果总是增加这个设计中类的数目。这就是为了要获取弹性而付出的代价。除非你的代码是一次性的，可以用完就扔掉（是呀！才怪！），那么其实状态模式的设计是绝对值 得的。其实真正支要的是你暴露给客户的类数目，而且我们有办法将这些额外的状态类全都隐藏起来。

让我们看一下另一种做法：如果你有一个应用，它有很多状态，但是你决定不将这些状态封装在不同的对象 中，那么你就会得到巨大的、整块的条件语句。

这会让你的代码不容易维护和理解。通过使用许多对象，你可以让状态变得很干净，在以后理解和维护它们时，就可以省下很多的工夫。

## 状态模式类图显示 State 是一个抽象类,但 你不是使用接口实现糖果机状态的吗？

是的。如果我们没有共同的功能可以放进抽 象矣中，就会使用接口。在你实现状态模式时，很可能 想使用抽象类。这么一来，当你以后需卖在抽象类中加 入新的方法时就很容易，不需要打破具体状态的实现。
