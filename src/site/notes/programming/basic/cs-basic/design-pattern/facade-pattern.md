---
{"aliases":["外观模式"],"tags":[],"review-dates":[],"dg-publish":true,"date-created":"2023-10-17-Tue, 6:36:50 pm","date-modified":"2023-10-17-Tue, 6:38:12 pm","permalink":"/programming/basic/cs-basic/design-pattern/facade-pattern/","dgPassFrontmatter":true}
---


# 外观模式

它改变接口的原因是为了简化接口。这 个模式被巧妙地命名为外观模式 (Facade-Pattern),之所以这么称呼，是因为它将一 个或数个类的复杂的一切都隐藏在背后，只显露出一个干净美好的外观

```ad-note
感觉外观模式和适配器模式其实没有太大的关联, 不明包为什么本书要把这两种模式放在一起

外观模式甚至现在来看就是一个稀松平常的接口包装而已
```

想要使用外观模式，我们创建 r 一个接口简化而统一的类，用来包装子系统中一个或多 个复杂的类。外观模式相当直接，很容易理解，这方面和许多其他的模式不太一样。但 这并不会降低它的威力：外观模式允许我们让客户和子系统之间避免紧耦合，而且稍后 你还会看到，外观模式也可以帮我们遵守一个新的面向对象原则

夕卜观模式提供了一个统一的接口，用来访问子系统中 的一群接口。外观定义了一个高层接口，让子系统更容易 使用

![](/img/user/programming/basic/cs-basic/design-pattern/facade-pattern/image-20231017183747328.png)

## FAQ

### 如果外观封装了子系统的 类，那么需要低层功能的客户如何接触 这些类?

外观没有“封装”子系统 的类，外观只提供简化的接口。所以客 户如果觉得有必要、依然可以直接使用 子系统的类。这是外观模式一个很好的 特征：提供简化的接口的同时，依然将 系统完型的功能暴露出来，以供需要的 人使用

### 外观会新增功能吗，或者它只是将每一个请求转由子系统执行

外观可以附加“聪明 的”功能，让使用子系统更方便。比方说，虽然你的家庭影院外现没有实现任 何新行为，但是外现却够聪明，知道爆 米花机要先开启然后才能开始爆米花

### 除了能够提供一个比较简 单的接口之外,外观模式还有其他的优点吗

外观模式也允许你将客户 实现从任何子系统中解相。比方说,你 得到了大笔加薪，所以想要升级你的家 庭影院，采用全新的和以前不一样接口 的组件。如果当初你的客户代码是针对 外观而不是针对子东统编写的，现在你 就不需要改变客户代鸡，只需要修改外 现代码（而且有可能厂商会提供新版的 外观代码）

### 我可不可以这样说，适配 器模式和外观模式之间的差异在于：适 配器包装一个类，而外观可以代表许多 类

不对！提醒你，适配器模式 将一个或多个类接口变成客户所期望的 一个接口。虽然大多数教科书所采用的 例子中适配器只适配一个类,但是你可 以适配许多类来提供一个接口让客户编 码。类似地，一个外观也可以只针对一 个拥有复杂接口的类提供同化的接口。 两种模式的差异,不在于它们“包 装” 了几个美，而是在于它们的意图。 适配器模式的意图是，“改变”接口符 合客户的期 2；而外观模式的意图是， 提供子系统的一个简化接口
