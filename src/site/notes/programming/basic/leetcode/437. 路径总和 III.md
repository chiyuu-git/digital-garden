---
{"dg-publish":true,"permalink":"/programming/basic/leetcode/437-iii/","tags":["leetcode/tree/traverse/path","leetcode/prefix-sum","leetcode/unsolved"]}
---


# [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

# Similar Question

leading to the advanced question

# Solution Tips

# 方案一: 双重递归

```js
  var pathSum = function(root, sum) {
    if(root===null) return 0
    let path = 0 
    dfs(root,sum)
    return path
    // 前序遍历每个节点，对每个节点调用acc函数
    function dfs(node,sum){
      if(node===null) return 
      acc(node,sum,0)
      dfs(node.left,sum)
      dfs(node.right,sum)
    }
    // 计算以当前节点为起点的路径是否符合题意
    function acc(node,sum,cur){
      if(node===null) return
  
      cur += node.val
      if(cur===sum) return path++
      
      acc(node.left,sum,cur)
      acc(node.right,sum,cur)
    }
  }
```

# 方案二: 前缀和

## 从叶节点开始

+ 显然，这种双递归的写法，有很多路径的重复计算
+ 这种计数问题，需要不重不漏，双递归通过不同起点保证不重，每个起点完整的搜索保证不漏
+ 换一种思路: 每次遍历到一个结点的时候，将其纳入路径当中，检查包含这个点时，会不会产生一个合法路径。由于之前这个点压根没出现，而现在必须包含，因此产生的方案是一定不重的： 包含本根结点的 && 不包含本根结点的
+ 利用了二叉树的一个特性，向下走有两条路，而从下向上走只有一条路（正是只有一条路这一点，免去了一个递归寻路的过程，只需沿着数组向前看就行）

  ```js
  var pathSum = function(root, sum) {
    if(root===null) return 0
    let path = 0,
        stack = [] 
    dfs(root,sum)
    return path
  
    function dfs(node,sum){
      if(node===null) return
      stack.push(node.val)
      let cur = 0
      for(let i = stack.length - 1; i >= 0; i--){
        cur += stack[i]
        if(cur === sum) path++
      }
      dfs(node.left,sum)
      dfs(node.right,sum)
      stack.pop()
    }
  }
  ```
