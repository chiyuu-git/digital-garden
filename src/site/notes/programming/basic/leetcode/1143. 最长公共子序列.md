---
{"dg-publish":true,"permalink":"/programming/basic/leetcode/1143/","tags":["leetcode/dp","leetcode/sub/sequence","leetcode/unsolved"]}
---


# [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

# Similar Question

# Solution Tips

# 方案一: 动态规划

给定两个字符串序列 **abcadf** , **acbad**，求这两个字符串的**最长**公共子序列

## 共性

分析第 i 行第 j 列时，它的字符组合仅能是小于等于 i 且小于等于 j 的情况

> 比如我们要填写 `T[2][2]` 时，那么此时等同于求字符串 **ac**,**ab**的最长公共子序列，填写 `T[4][5]` 时，那么此时等同于求 **acba**，**abcad**的最长公共子序列长度。

逐行填写表格，每一行的结果都是目前最优的选择，新一行的选择参考于上一行

## 初始化

我们给两个子序列前面都加一个空字符，即

```js
str1 = ["","a","c","b","a","d"],
str2 = ["","a","b","c","a","d","f"],
```

这一步其实就是初始化的操作，因为这类问题横向纵向都需要分析

为什么填一堆 0 呢？表示字符串无法匹配，你可以理解这是一种辅助的计算方式，**在分析具体子序列时，不把构建的空字符纳入考虑范围**

使用 `T[i][j]` 表示组合的子序列长度。

## 逐行分析

### I = 1

- `i=1 j=1`：此时等同于求字符串 **a**和**a**的最长公共子序列长度，很显然结果为 1。
- `i=1 j=2`：此时等同于求字符串 **a**和**ab**的最长公共子序列长度，结果为 1。
- `i=1 j=3`：此时等同于求字符串 **a**和**abc**的最长公共子序列长度，结果为 1。

只要一个序列只有一个字符，那么另一个序列无论多长，它们的最长公共子序列长度最多只能为 1。所以 i=1 行剩余空格都填 1。

### I = 2

- `i=2 j=1`：此时等同于求字符串 **ac**和**a**的最长公共子序列长度，结果为 1。
- `i=2 j=2`：此时等同于求字符串 **ac**和**ab**的最长公共子序列长度，结果为 1。
- `i=2 j=3`：此时等同于求字符串 **ac**和**abc**的最长公共子序列长度。因为根据一开始的分析，求最长公共子序列时，子序列是可以不连续的，因此这两个序列的最长公共子序列应该是 **ac**，所以这里表格应该填 2

我们从 `T[2][3]` 这一个展开分析规律：

  - 很显然去除 **c** 这个公共字符后，两个字符串还剩下 **a**, **ab**。这个其实就是填写 ` T[1][2] ` 时的组合
  - 也就是我们可以假设当 `str1[i] == str2[j]` 时 `T[i][j]=T[i-1][j-1]+1`
  - 当 `str1[i] != str2[j]` 时，`T[i][j]` 的值，取它上方或左边的较大值，即 `[i][j] = max(T[i-1][j],T[i][j-1])`
  - 举个例子，比如对于 **ace** 和 **bc** 而言，他们的最长公共子序列的长度等于:
	  1. **ace** 和 **b** 的最长公共子序列长度 0 与
	  2. **ac** 和 **bc** 的最长公共子序列长度 1 的最大值，即 1。

用一句通俗的话来描述这种 `T[i][j]` 规律，就是：

  - 有新的公共字符，等于左上角加一
  - **没有新的公共字符，则取上或左最大值，如果上左一样大，优先取左**

### 左边 or 上边, 首先取左?

因为 `str1[i] != str2[j]`, 那就可以分别舍弃 `str1[i]` 和 `str2[j]`, 获取舍弃它们之后的 LCS

为啥要优先取左边的呢? 不清楚

## 初始化

从我们的分析结果也可以看出，新一格的结果可能由左上，左，上，中的某一个决定，在循环中初始化的困难太大，所以统一在前面加上一个空字符串，全部初始化为 0，可以大大减轻工作量

## 输出结果

我们子序列保存在名为 s 的数组中，从表格中反向搜索，找到目标字符后，每次都把目标字符插入到数组最前面。

根据前面提供的填表口诀，我们可以反向得出寻找子序列的口诀: 如果 `T[i][j]` 来自左上角加一，则是子序列，否则向左或上回退。如果上左一样大，优先取左

## 实现

```js
  function longestSub(str1,str2){
    let T = []
    // 简化初始化行列的操作
    str1 = ' '+str1
    str2 = ' '+str2
    for (let i = 0; i < str1.length; i++) {
      T[i] = []
      for (let j = 0; j < str2.length; j++) {
        // 初始化操作
        if(i===0 || j===0){
          T[i][j]=0
          continue
        }
        // 初始化已经完成，剩下的直接操作即可
        if(str1[i]===str2[j]){
          // 发现新的公共字符，等于左上角(刨除公共字符后的子串)+1
          T[i][j] = T[i-1][j-1]+1
        }else{
          // 没有新的公共字符
          T[i][j] = Math.max(T[i-1][j],T[i][j-1])
        }
      }
    }
    findValue(str1,str2,T)
    return T
  }
  
  console.log(longestSub('acbad','abcadf'))
```

```js
  function findValue(str1,str2,T){
    let ret = ''
    let i = str1.length-1
    let j = str2.length-1
    while(i>=0&&j>=0){
      if(str1[i]===str2[j]){
        // 公共字符
        ret = str1[i] + ret
        // 回退到左上角
        i--
        j--
      }else{
        // 非公共字符，判断源,向源回退
        T[i-1][j]>T[i][j-1]?i--:j--
      }
    }
    console.log(ret)
  }
```

![1555314073094](/img/user/programming/basic/algorithm/dynamic-programming/!dynamic-programming/1555314073094.png)

![pCIaGdA.png](https://s1.ax1x.com/2023/07/16/pCIaGdA.png)

## 优化实现

### 负号索引初始化

  ```js
  function longestSub(str1,str2){
    const len1 = str1.length 
    const len2 = str2.length 
    // 初始化行列的操作
    let dp = new Array(len1) // 列
    dp[-1] = new Array(len2).fill(0) // 负1行
    dp[-1][-1] = 0
    for (let i = 0; i < len1; i++) { // 行
      dp[i] = new Array(len2)
      dp[i][-1] = 0
    }
    for (let i = 0; i < len1; i++) {
      for (let j = 0; j < len2; j++) {
        if(str1[i]===str2[j]){
          // 发现新的公共字符，等于左上角(刨除公共字符后的子串)+1
          dp[i][j] = dp[i-1][j-1]+1
        }else{
          // 没有新的公共字符
          dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])
        }
      }
    }
    findValue(str1,str2,dp)
    return dp
  }
  ```

### I - 1 索引, 优化初始化逻辑

`dp[i][j]` 代表的是 `i - 1 & j - 1` 的情况

```js
var longestCommonSubsequence = function(text1, text2) {
    // 和最长公共子数组差不多吧, 都是要二维dp然后拼接 + 1 的, 尝试做一下吧
    const dp = Array.from({ length: text1.length + 1 }, () => Array.from({ length: text2.length + 1 }, () => 0));

    let res = 0;
    for (let i = 1; i <= text1.length; i++) {
        for (let j = 1; j <= text2.length; j++) {
            if (text1[i - 1] === text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                res = Math.max(res, dp[i][j]);
            }
            else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    return res;
};
```

### 滚动数组

此时无法返回子序列

  ```js
  function longestSub(str1,str2){
    const len1 = str1.length 
    const len2 = str2.length 
    // 滚动数组
    let lineA =  new Array(len2).fill(0)
    lineA[-1] = 0
    let lineB = new Array(len2)
    lineB[-1] = 0
    let referLine = lineA
    let currentLine = lineB
    for (let i = 0; i < len1; i++) {
      for (let j = 0; j < len2; j++) {
        if(str1[i]===str2[j]){
          // 发现新的公共字符，等于左上角(刨除公共字符后的子串)+1
          // dp[i][j] = dp[i-1][j-1]+1
          currentLine[j] = referLine[j-1] + 1
        }else{
          // 没有新的公共字符
          // dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])
          currentLine[j] = Math.max(currentLine[j-1],referLine[j])
        }
      }
      // 滚动数组
      console.log(currentLine)
      ;([referLine,currentLine] = [currentLine,referLine])
    }
    return referLine[len1-1]
  }
  ```
