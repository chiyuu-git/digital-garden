---
{"dg-publish":true,"permalink":"/programming/basic/leetcode/220-iii/","tags":["leetcode/unsolved","leetcode/pointer/sliding-window"]}
---


# [220. 存在重复元素 III](https://leetcode.cn/problems/contains-duplicate-iii/)

# Similar Question

没感觉到和哈希有什么关系

leading to the advanced question

# Solution Tips

# 方案一: 暴力法

```js
var containsNearbyAlmostDuplicate = function(nums, k, t) {
    // 排序之后, 两个滑动窗口感觉是比较好的处理方法, 再想想哈希表有没有合适的方案
    // 肯定不能排序呀, 所以只能是单个滑动窗口, 不断的判断, 窗口的指针不断的相撞又分离即可

    // 可以生成一个排序哈希映射索引, keys 是 val 升序, 然后比对存储的索引, 就是说排序的同时生成这样一个哈希表, 但是其实本质是和方法一一样的, 只不过滑动的窗口变成了哈希表上 val 滑动而已, 还是没想到特别适合哈希表的方法

    
    // let left = 0;
    // let right = 0 + k;

    // while (left < right && right < nums.length) {
    //     if (Math.abs(nums[left] - nums[right]) <= t) {
    //         return true;
    //     }

    //     if (left < right) {
    //         left++
    //     }
    //     else {
    //         right++
    //     }
    // }
    // 滑动窗口感觉漏元素了, 还是没有理解透彻, 还不如暴力法限制 j 为 i + K
    
    for (let i = 0; i < nums.length; i++) {
        const left = nums[i];
        for (let j = i + 1; j <= i + k; j++) {
            const right = nums[j];
            if (Math.abs(left - right) <= t) {
                return true;
            }
        }
    }

    return false;
};

let nums = [-3,3,-6], k = 2, t = 3
console.log(containsNearbyAlmostDuplicate(nums, k, t));
```
