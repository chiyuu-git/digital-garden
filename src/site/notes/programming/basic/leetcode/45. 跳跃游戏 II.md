---
{"dg-publish":true,"permalink":"/programming/basic/leetcode/45-ii/","tags":["leetcode/greedy-algorithm"]}
---


# [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

# Similar Question

# Solution Tips

# 方案一: 贪心

```js
var jump = function(nums) {
    // 这次也是倒过来, 找到最远的能覆盖 last 的 index, 就跳到那就行
    // 只保留最大的 cover 就行, 小的就不要走了
    // 在能跳的范围内, 要去跳下一个位置能跳的最远的
    // 那就是在能跳的范围内, 再找一个最大值
    const n = nums.length;
    if (n === 1) return 0;
    let step = 1;
    let start = 0;
    while (start < nums.length) {
        const end = start + nums[start];
        if (end > n - 1) {
            return step;
        }
        // 找到 start 到 end 间的最大值
        let nextStep = 0;
        let curMax = 0;
        for (let i = start; i <= end; i++) {
            if (i + nums[i] > curMax) {
                curMax = i + nums[i];
                nextStep = i;
            }
        }
        start = nextStep;
        step++;
        if (curMax >= n - 1) {
            return step;
        }

    }
    return step;
};

console.log(jump([7,0,9,6,9,6,1,7,9,0,1,2,9,0,3]))
```
