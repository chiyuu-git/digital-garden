---
{"dg-publish":true,"permalink":"/programming/basic/algorithm/greedy-algoritm/"}
---


# 贪心算法

## 概述

贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。

1. 根据实际问题，选取一个度量标准，然后按照这种标准对 n 个输入进行排序，并按次序一次输入一个量
2. 如果输入和当前已构成的部分最优解不能产生下一个可行解，则不把此输入加入到部分解中，否则将当前输入合并到解中从而得到新的部分最优解
3. 这一过程一直持续知道 n 个输入都被处理完毕，计入最优解中的输入子集构成最优解

这种能够得到某种意义下的最优解的分级处理方法被称为贪心算法

## 为什么

为什么这种问题局部的最优可以逐渐扩展到全局的最优?

## 和动态规划的区别

都是一个推导的过程

感觉一起处理吧? 还是太难区分贪心和动归

## TODO

散落四处的贪心算法处理, 打一下 tag, 归类处理一下


# 背包问题

各种大米，小米，糯米，黄米，等重量 20kg 以内，价格最高

商品按价格排序，先装价格最高的，装完再装价格次高的，次次高的

# 最小生成树

Prim 算法

Kruskal 算法

# 最少硬币找零问题

最少硬币找零问题也能用贪心算法解决。大部分情况下的结果是最优的，不过对有些面额而言，结果不会是最优的。

  ```js
  function MinCoinChange(coins){ 
    var coins = coins; //{1} 
  
    this.makeChange = function(amount) { 
      var change = [], 
          total = 0; 
      for (var i=coins.length; i>=0; i--){ //{2} 
        var coin = coins[i]; 
        while (total + coin <= amount) { //{3} 
          change.push(coin);           //{4} 
          total += coin;               //{5} 
        } 
      } 
      return change; 
    }; 
  } 
  
  ```

对每个面额（行{2}——从大到小），把它的值和 total 相加后，total 需要小于 amount（行 {3}）。我们会将当前面额 coin 添加到结果中（行{4}），也会将它和 total 相加（行{5}）

如你所见，这个解法很简单。从最大面额的硬币开始，拿尽可能多的这种硬币找零。当无法再拿更多这种价值的硬币时，开始拿第二大价值的硬币，依次继续。

# 直接法 + 模拟法

[605. 种花问题](../leetcode/605.%20种花问题.md)