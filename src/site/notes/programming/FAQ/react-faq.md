---
{"dg-publish":true,"permalink":"/programming/faq/react-faq/"}
---


# setState 是同步还是异步？

## V18 之前

1. React 是希望 setState 表现为异步的，因为批量更新可以优化性能。因此在 React 能够管控到的地方，比如生命周期钩子和合成事件回调函数内，表现为异步。
2. 在定时器和原生事件里，因为 React 管控不到，所以表现为同步。
3. 在某些情况下，我们需要立即获取更新后的状态，这时可以使用第二个可选参数 callback，在状态更新后立即执行回调函数来获取更新后的状态。例如：

```javascript
this.setState({ counter: this.state.counter + 1 }, () => {
  console.log(this.state.counter); // 输出更新后的值
});
```

## V18 之后

1. React18 之后，默认所有的操作都放到批处理中，因此 setState 不管在那儿调用都是异步的了。
2. 如果希望同步更新，可以使用 flushSync 这个 API。

# Redux 中间件是什么？实现原理？

中间件的本质就是个函数，在 Redux 每次写数据的时候执行，用来实现一些通用的功能。

常见的中间件功能包括异步中间件、持久化中间件、log 中间件。

Redux 中间件的实现原理和 Koa 中间件、Axios 拦截器类似，数组里面存函数，然后 compose 调用中间件函数，并传递参数给中间件。

# React 逻辑复用方式有哪些？

组件封装和逻辑复用，是前端进阶必备的，小伙伴们可以多花点时间深入研究，这里只是简要总结。

1. Mixin：有很多缺点，已被弃用，可以不考虑。
2. HOC(高阶组件)：高阶组件是一个函数，它接收一个组件作为参数并返回一个新的组件。高阶组件可以将一些通用的逻辑（如：数据获取、权限验证、错误处理等）封装到一个函数中，并将其作为高阶组件的参数传递给其他组件使用，HOC 一般以 withXxx 命名，并可以结合装饰器优雅地使用。
3. Render Props：通过在组件中传递一个函数作为 prop，该函数将用于渲染组件的内容。这个函数可以接收组件需要的数据和方法，并返回 React 元素。
4. Hooks：自定义 Hooks，将通用逻辑封装到 useXxx 函数中，可以在多个组件内使用，常见的像数据请求、表单、防抖节流、拖拽等。

# 使用 Hooks 有踩过哪些坑？

1. useEffect 中没有正确设置依赖数组导致死循环。
2. useEffect 中没有清除副作用导致内存泄漏。
3. 在条件语句和循环中使用 Hooks 导致报错。
4. 闭包陷阱。

```JS
import React, { useState, useEffect } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      // 这里的 count 变量是捕获的初始值，而不是最新的状态
      setCount(count + 1);
    }, 1000);

    return () => clearInterval(interval);
  }, []); // 依赖数组为空，只会执行一次

  return <div>{count}</div>;
}

export default Counter;

```

为了避免闭包陷阱，可以使用 useCallback 和 useMemo 来确保回调函数和依赖项都在正确的上下文中更新。另外，也可以将涉及到状态更新的函数移到 useEffect 内部，以保证使用正确的状态值。

总之，闭包陷阱是在使用 React Hooks 时需要特别注意的一个问题，理解它可以帮助你避免在组件中出现奇怪的问题。

# React 代码层面有哪些性能优化的方式？

1. React.memo()：可以缓存组件的渲染结果，避免不必要的重渲染。它接受一个函数组件，并返回一个新的组件，新组件将只在 props 发生变化时才重新渲染。
2. useMemo 和 useCallback。
4. 使用 React.lazy() 和 Suspense 进行组件懒加载。

# React Rerender

其实大部分问题确实不是性能问题, 而是影响调试. 打一个 log 结果出现几十条, 打一个断点结果一直在原地打转.

# Hooks 实现原理？

篇幅有限，这里只做简要总结，实现细节后续会出文讲解。

**1. memorizedState**：Fiber 节点上有个属性叫 memorizedState，所有的 Hooks 都是围绕这个 memorizedState 来实现的，把要存的状态和函数队列存到这个属性上，然后按需求做增删改查就行了。

**2. 链表存储状态**：为了保证 Hooks 状态的序列，React 采用链表来保存函数式组件的 state，使用 next 属性来连接前后两个状态序列。

# 怎么理解 Fiber 和并发模式？

# 为什么要设计并发模式？

在 React 的旧版本中，当组件状态发生变化时，React 会将整个组件树进行递归遍历，生成新的虚拟 DOM 树，并与旧的虚拟 DOM 树进行比较，找出需要更新的部分，然后将这些部分更新到 DOM 中。这种遍历方式虽然简单，但是在组件树变得非常大、复杂的情况下，会导致渲染和更新性能下降，造成页面卡顿甚至无法响应用户操作的情况。为了解决这个问题，React 引入了并发模式。

# Fiber 是什么？

1. Fiber 是一种数据结构，由 VDOM 转化生成。
2. Fiber 的思想是将组件树的遍历过程拆分成多个小的、可中断的任务，以实现更细粒度的控制和优化。
3. 具体来说，Fiber 将每个组件看作是一个执行单元，并将组件树转换成一棵 Fiber 树。每个 Fiber 节点都包含了组件的状态和一些额外的信息，例如优先级、副作用等。
4. 在更新过程中，React 会根据 Fiber 节点的优先级，将 Fiber 树转换成一个任务队列，然后按照优先级进行调度和执行。React 还会利用浏览器提供的 requestIdleCallback API 来分配空闲时间，以避免阻塞渲染线程。
5. 由于 Fiber 将组件树的遍历过程拆分成了多个小的、可中断的任务，因此 React 可以在需要更新的部分进行优化，从而提高渲染和更新的性能。例如，在执行更新任务时，React 可以根据优先级调整任务的执行顺序，避免低优先级任务阻塞高优先级任务的执行，提高了应用程序的响应速度和性能。

# JSX 和模板引擎有什么区别？

1. JSX：更加灵活，既可以写标签，也可以使用 JS 语法和表达式，在做复杂渲染时更得心应手。
2. 模板引擎：更简单易上手，开发效率高，结合指令的可读性也比较好。
3. JSX 太灵活就导致没法给编译器提供太多的优化线索，不好做静态优化，模板引擎可以在编译时做静态标记，性能更好。
4. JSX 只是个编译工具，Vue 经过一定的配置也可以使用。

# Vue 和 React 有哪些区别，你更喜欢哪个

这是个开放题，不建议背答案，可以从**生态、语法、性能、原理、开发体验**等方面去试着比较一下。

# 有了解过哪些类 React 框架，谈谈你对它们的看法

Preact：可以理解为简易版 React，但是和 React 有一样的 API，性能比 React 还好，甚至也实现了并发模式，对于想要阅读 React 源码又觉得难的同学，可以看一看 Preact 的源码。

Svelte：无虚拟 Dom，依靠编译器和纯响应式的轻量级框架，然而性能却非常好。

SolidJS：和 Svelte 类似，但是 SolidJS 的语法更接近于 React，Svelte 的语法接近 Vue。

总结一下：

1. 这些类 React 或者类 Vue 框架，可能在某一方面或者某些方面表现很出色。
2. 在开发成熟项目时，还是尽量选择 Vue 和 React，因为毕竟生态和解决方案更多。
3. 时间允许的话推荐阅读这些框架的源码，它们的代码量相对少，容易阅读，能让你有一个更广的视野来看待前端框架的原理和设计思路。
